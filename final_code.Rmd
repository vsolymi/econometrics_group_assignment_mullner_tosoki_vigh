---
title: "good"
author: "Tosoki Samu, Vigh Solyom, Mullner Edvard"
date: "2025-10-28"
output:
  pdf_document:
    latex_engine: xelatex
---


Samu's working directory
```{r}
rm(list = ls())
setwd("~/Library/Mobile Documents/com~apple~CloudDocs/Downloads/korvó/mester/econometrics")
```


packages
```{r}
library(tidyverse)
library(readxl)
library(dplyr)
library(stringr)
library(tidygeocoder)
library(rnaturalearth)
library(rnaturalearthdata)
library(httr)
library(jsonlite)
library(readr)
library(geosphere)
library(estimatr)
library(stargazer)
library(sf)
library(ggplot2)
library(osmdata)
library(glue)
library(gtsummary)
library(kableExtra)
library(patchwork)
library(lmtest)
library(car)
library(sandwich)
```

data (and its preparation)
```{r}
prices <- read_xlsx("2024.10.01-10.07.xlsx")
attach(prices)
str(prices)
Company <- as.factor(Company)
Date <- as.Date(Date)
prices$id <- paste(Settlement, Company, Address, sep = " | ")
```

creating variables from the original dataset
```{r}
#creating the weekly avg price per station variable
weekly <- prices %>%
  group_by(id, Settlement, Company, Address) %>%
  summarise(
    gasoline_avg = mean(`Gasoline (HUF/l)`, na.rm = TRUE),
    diesel_avg   = mean(`Diesel (HUF/l)`,   na.rm = TRUE),
    n_days       = n_distinct(Date),
    .groups = "drop")

#category of stations based on Company
levels(Company)
premium <- c("Mol","Shell","Omv","Orlen")
discount <- c("Auchan","Avia","Oil!","Mobil Petrol","Mol Partner+") #this categorization is subjective, might be possible to improve

weekly <- weekly %>%
  mutate(
    brand_cat = case_when(
      Company %in% premium  ~ "premium",
      Company %in% discount ~ "discount",
      TRUE                  ~ "small"))

#competion variable: number of stations in the same settlement
sett_counts <- weekly %>% count(Settlement, name = "n_sett_stations")

#alternative competition variable: number of stations from different brands in the same settlement
competitors <- weekly %>%
  count(Settlement, Company, name = "brand_in_sett") %>%
  right_join(weekly, by = c("Settlement","Company")) %>%
  group_by(Settlement) %>%
  mutate(total_sett = n()) %>%
  ungroup() %>%
  mutate(n_competitors_other_brand = total_sett - brand_in_sett)
weekly <- competitors


#brand HHI variable: measures market concentration
brand_counts <- weekly %>% 
  count(Settlement, Company, name = "n") %>%
  left_join(sett_counts, by = "Settlement") %>%
  mutate(share = n / n_sett_stations)

hhi <- brand_counts %>%
  group_by(Settlement) %>%
  summarise(hhi_brand = sum((share*100)^2)/10000, .groups = "drop")

#brand category shares in each settlement
cat_counts <- weekly %>% 
  count(Settlement, brand_cat, name = "n") %>%
  tidyr::pivot_wider(names_from = brand_cat, values_from = n, values_fill = 0) %>%
  left_join(sett_counts, by = "Settlement") %>%
  mutate(
    share_small    = ifelse(is.na(small), 0, small) / n_sett_stations,
    share_premium  = ifelse(is.na(premium), 0, premium) / n_sett_stations,
    share_discount = ifelse(is.na(discount), 0, discount) / n_sett_stations
  ) %>%
  select(Settlement, share_small, share_premium, share_discount)
```




creating further variables from KSH and other data
```{r}
#population density variable
dgh <- read_excel("dgh_download_2025.xlsx", skip = 2) %>%
  select(Settlement = `Locality name`,
         area_ha    = `Area (hectare)`,
         population = `Resident population`) %>%
  mutate(
    Settlement = str_squish(as.character(Settlement)),
    pop_density = population / (area_ha / 100)) #this gives people per km2
```


on highway variable
```{r}
weekly <- weekly %>%
  mutate(
    on_highway =
      str_detect(
        Address,
        regex("M[0-9]{1,2}|autópálya|pihenő|km[- ]?szelv", ignore_case = TRUE)
      ) %>%
      as.integer()
  )
table(weekly$on_highway, useNA="ifany") #81 stations are on highways; usually they occur in pairs (one on each side) so having uneven number of stations seems strange but not impossible
```

get the settlement coordinates
```{r}
sett <- weekly %>%
  distinct(Settlement) %>%
  mutate(Settlement = str_squish(as.character(Settlement)))
if (!file.exists("sett_coords.csv")) { #it is important to have the sett_coords.csv data in the proper directory, otherwise this code takes 5+ minutes to run
  set.seed(1)
  sett_coords <- sett %>%
    mutate(query = paste(Settlement, "Hungary")) %>%
    geocode(address = query, method = "osm",
            lat = lat, long = lon, limit = 1, min_time = 0.15)
  write.csv(sett_coords, "sett_coords.csv", row.names = FALSE) 
} else {
  sett_coords <- read.csv("sett_coords.csv", stringsAsFactors = FALSE)
}
```


creating the border distance variables (cont. and dummy)
```{r}
sf::sf_use_s2(TRUE)  

stopifnot(exists("weekly"), "Settlement" %in% names(weekly))

sett_coords <- read_csv("sett_coords.csv", show_col_types = FALSE) %>%
  transmute(
    Settlement = str_squish(as.character(Settlement)),
    lat = as.numeric(lat),
    lon = as.numeric(lon)
  ) %>%
  filter(!is.na(lat), !is.na(lon), Settlement != "") %>%
  distinct(Settlement, .keep_all = TRUE)
stopifnot(nrow(sett_coords) > 0)

sett_sf <- st_as_sf(sett_coords, coords = c("lon","lat"), crs = 4326, remove = FALSE)

hungary <- ne_countries(scale = "medium", country = "Hungary", returnclass = "sf") |>
  st_make_valid() |> st_transform(4326)

neighbors <- c("Austria","Slovakia","Slovenia","Croatia","Romania","Serbia","Ukraine")
nb <- ne_countries(scale = "medium", country = neighbors, returnclass = "sf") |>
  st_make_valid() |> st_transform(4326)

hu_edge   <- st_boundary(st_geometry(hungary))    
nb_edge   <- st_boundary(st_geometry(nb))        
nb_union  <- st_union(nb_edge)                     

border_raw <- suppressWarnings(st_intersection(hu_edge, nb_union)) 
border_sfc <- st_collection_extract(border_raw, "LINESTRING", warn = FALSE)
border_lines <- st_as_sf(data.frame(geometry = border_sfc), crs = 4326)
stopifnot(nrow(border_lines) > 0)


midpts <- st_centroid(border_lines$geometry)

midpts <- st_cast(midpts, "POINT", warn = FALSE)
if (length(midpts) != nrow(border_lines)) {
  midpts <- st_centroid(border_lines$geometry)
}
midpts_sf <- st_as_sf(data.frame(geometry = midpts), crs = 4326)

nearest_idx <- st_nearest_feature(midpts_sf, nb)
border_lines$neighbor <- nb$name_long[nearest_idx]

# for some reason these two line of codes do not work
schengen_set <- c("Austria","Slovakia","Slovenia","Croatia")
border_lines$is_schengen <- border_lines$neighbor %in% schengen_set

D <- st_distance(sett_sf, border_lines)  # units mátrix (m)
min_idx <- apply(D, 1, which.min)
min_m   <- apply(D, 1, min)

sett_out <- sett_coords %>%
  mutate(
    dist_border_km          = as.numeric(min_m) / 1000,
  #  nearest_country_border  = border_lines$neighbor[min_idx],
  #  nearest_border_schengen = as.integer(border_lines$is_schengen[min_idx]),
    near_border_10km        = as.integer(dist_border_km <= 10),
    near_border_20km        = as.integer(dist_border_km <= 20)
  )

weekly <- weekly %>%
  mutate(Settlement = str_squish(as.character(Settlement))) %>%
  left_join(sett_out, by = "Settlement")

stopifnot(all(is.finite(weekly$dist_border_km)), all(weekly$dist_border_km >= 0))
print(summary(weekly$dist_border_km))
print(table(Schengen = weekly$nearest_border_schengen, useNA = "ifany"))
print(table(`≤20km_határtól` = weekly$near_border_20km, useNA = "ifany"))

ggplot() +
  geom_sf(data = hungary, fill = NA, linewidth = 0.4) +
  geom_sf(data = border_lines, linewidth = 0.6, alpha = 0.7) +
  geom_point(
    data = sett_out,
    aes(x = lon, y = lat, color = near_border_20km == 1),
    size = 1.9, alpha = 0.9
  ) +
  scale_color_manual(values = c("FALSE" = "#2C7FB8", "TRUE" = "#D7301F"),
                     labels = c("FALSE"="> 20 km", "TRUE"="≤ 20 km"),
                     name = "Border distance") +
  scale_linetype_manual(values = c("TRUE"="solid","FALSE"="dashed"),
                        labels = c("TRUE"="Schengen", "FALSE"="Nem Schengen"),
                        name = "Szomszéd") +
  coord_sf(xlim = st_bbox(hungary)[c("xmin","xmax")],
           ylim = st_bbox(hungary)[c("ymin","ymax")], expand = FALSE) +
  theme_minimal(base_size = 12) +
  theme(panel.grid = element_blank(), legend.position = "right")

```


creating final dataset
```{r}
data <- weekly %>%
  left_join(sett_counts,   by = "Settlement") %>%
  left_join(hhi,           by = "Settlement") %>%
  left_join(cat_counts,    by = "Settlement") %>%
  left_join(sett_out,      by = "Settlement") %>%      
  left_join(dgh,           by = "Settlement") %>%      
  mutate(
    brand_cat = factor(brand_cat, levels = c("small","discount","premium")),
    brand_cat_discount = as.integer(brand_cat == "discount"),
    brand_cat_premium  = as.integer(brand_cat == "premium"),
    log_n_sett = log(n_sett_stations),
    log_n_competitors_other_brand = log(n_competitors_other_brand + 0.00001)
  )

names(data)


data_clean <- data %>%
  select(-ends_with(".y")) %>%
  rename_with(~sub("\\.x$", "", .), ends_with(".x"))


# quick check
str(data_clean)
write.csv(data_clean, "modelling_data.csv", row.names = FALSE) #save data
```


descriptive plots
```{r}
data <- read.csv("modelling_data.csv")

#histograms of gasoline and diesel prices
histogram_gasoline <- ggplot(data, aes(x = gasoline_avg)) +
  geom_histogram(
    color = "black",
    fill= "#bebada",
    binwidth = 0.5, 
    alpha = 0.8
  ) +
  labs(
    x = "Average Gasoline Price (HUF/liter)",
    y = "Frequency"
  ) +
  theme_minimal(base_size = 12) 


histogram_diesel <- ggplot(data, aes(x = diesel_avg)) +
  geom_histogram(
    color = "black",
    fill= "#bebada",
    binwidth = 0.5, 
    alpha = 0.8
  ) +
  labs(
    x = "Average Diesel Price (HUF/liter)",
    y = "Frequency"
  ) +
  theme_minimal(base_size = 12) 
#combine them 
histogram_gasoline + histogram_diesel

# boxplots of gasoline and diesel prices by brand category
brand_cat_boxplot<-ggplot(data, aes(x = brand_cat, y = gasoline_avg, fill = brand_cat)) +
  geom_boxplot(alpha = 0.7, outlier.shape = 21) +
  scale_fill_brewer(palette = "PuOr",
                    name="Brand category",
                    labels = c(
    "small"    = "Small",
    "discount" = "Discount",
    "premium"  = "Premium")) +
  labs(
    y = "Gasoline Price (HUF/liter)") +
  theme_minimal(base_size = 12)

brand_cat_boxplot_diesel<-ggplot(data, aes(x = brand_cat, y = diesel_avg, fill = brand_cat)) +
  geom_boxplot(alpha = 0.7, outlier.shape = 21) +
  scale_fill_brewer(palette = "PuOr",
                    name="Brand category",
                    labels = c(
    "small"    = "Small",
    "discount" = "Discount",
    "premium"  = "Premium")) +
  labs(
    y = "Diesel Price (HUF/liter)") +
  theme_minimal(base_size = 12)

#combine them
(brand_cat_boxplot + brand_cat_boxplot_diesel) +
  plot_layout(ncol = 2, guides = "collect") &
  theme(legend.position = "bottom")

#scatter plot of HHI vs gasoline price
ggplot(data, aes(x = hhi_brand, y = gasoline_avg)) +
  geom_point(alpha = 0.6, size = 2, colour = "#1f77b4") +
  geom_smooth(method = "lm", se = TRUE, colour = "black", linewidth = 0.8) +
  labs(
    x = "HHI",
    y = "Average Gasoline Price (HUF/liter)") +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    panel.grid.minor = element_blank()
  )

#pop density vs avg price
ggplot(data, aes(x = pop_density, y = gasoline_avg)) +
  geom_point(alpha = 0.6, size = 2, colour = "#1f77b4") +
  geom_smooth(method = "lm", se = TRUE, colour = "black", linewidth = 0.8) +
  scale_x_continuous(trans = "log10", labels = scales::comma) +
  labs(
    x = "Population Density (people per km², log scale)",
    y = "Average Gasoline Price (HUF/liter)"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    panel.grid.minor = element_blank()
  )  

#on highway boxplot vs price
ggplot(data, aes(x = factor(on_highway), y = gasoline_avg, fill = factor(on_highway))) +
  geom_boxplot(alpha = 0.7, outlier.shape = 21) +
  scale_fill_manual(
    name = "Station location",
    labels = c("0" = "Off highway", "1" = "On highway"),
    values = c("1" = "#FDB462", "0" = "grey40")
  ) +
  labs(
    x = "Station location",
    y = "Gasoline Price (HUF/liter, weekly average)"
  ) +
  theme_minimal(base_size = 12)

#near border boxplot vs price 
ggplot(data, aes(x = factor(near_border_20km), y = gasoline_avg, fill = factor(near_border_20km))) +
  geom_boxplot(alpha = 0.7, outlier.shape = 21) +
  scale_fill_manual(
    name = "Station location",
    labels = c("0" = "Not near border", "1" = "Near border"),
    values = c("1" = "#FDB462", "0" = "grey40")
  ) +
  labs(
    x = "Station location",
    y = "Gasoline Price (HUF/liter, weekly average)"
  ) +
  theme_minimal(base_size = 12)

#interaction of the two
data_summary <- data %>%
  mutate(
    Highway_location = ifelse(on_highway == 1, "On highway", "Off highway"),
    Border_location = ifelse(near_border_20km == 1, "Within 20km", "Farther than 20km")
  ) %>%
  group_by(Highway_location, Border_location) %>%
  summarise(
    mean_gasoline = mean(gasoline_avg, na.rm = TRUE),
    sd_gasoline = sd(gasoline_avg, na.rm = TRUE),
    n = n(),
    .groups = 'drop' 
  )

ggplot(data_summary, aes(x = Highway_location, y = mean_gasoline, fill = Border_location)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9), alpha = 0.8) +
  
  geom_errorbar(
    aes(ymin = mean_gasoline - sd_gasoline, ymax = mean_gasoline + sd_gasoline),
    position = position_dodge(width = 0.9),
    width = 0.25,
    color = "black"
  ) +
  
  scale_fill_manual(values = c("Within 20km" = "#FDB462", "Farther than 20km" = "grey40")) +
  
  labs(
    x = "Highway Location",
    y = "Mean Gasoline Price (HUF/liter)",
    fill = "Border Location"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    legend.position = "bottom"
  )
```


creating regression models
```{r}
set.seed(123)
rm(list = ls())
data <- read.csv("modelling_data.csv")

data <- data %>% mutate(across(c('Settlement',
                                 "Company",
                                 "brand_cat",
                                 "on_highway",
                                 "near_border_10km",
                                 "near_border_20km",
                                 ), as.factor))
```

splitting data into train and test set for later evaluation/external validity check
```{r}
train_index <- sample(seq_len(nrow(data)), size = 0.8 * nrow(data))
train_data <- data[train_index, ]
test_data  <- data[-train_index, ]
```


# I. Gasoline
### Effect of brand premium
```{r}
train_data$brand_cat<-relevel(train_data$brand_cat, "premium")

model1<-lm(gasoline_avg~
             brand_cat, train_data)

bptest(model1) 
resettest(model1) #It’s testing something trivial: whether a polynomial transformation of a single variable adds explanatory power
```

### Controlled for by local market structure
```{r}
model2<-lm(gasoline_avg~
             brand_cat+
             brand_in_sett+
             n_competitors_other_brand+
             hhi_brand, train_data)

vif(model2) #tolerable multicollinearity
bptest(model2) #the residuals are heteroskedastic
resettest(model2) #incorrectly specified
waldtest(model1, model2) #local market structure increases model fit signficantly

```
Smaller and discount brands both operate with lower prices on average
An increase of stations of one brand increases its local monopoly effect as well as their brand effect. Their dense local presence might signal reliability or service quality, allowing higher prices.
An increase of competitive stations causes an effect the other way around

### Controlled for by local market structure and population density
```{r}

model3<-lm(gasoline_avg~
             brand_cat+
             brand_in_sett+
             n_competitors_other_brand+
             hhi_brand+
             pop_density, train_data)

vif(model3) #tolerable multicollinearity
bptest(model3) #the residuals are heteroskedastic
resettest(model3) #incorrectly specified
#waldtest(model2, model3) #anova logic breaks bc pop.density has lower sample size
```
Higher throughput (more customers per station) may allow operators to maintain margins with lower prices.
Higher density - cities, where public transport is more widely available - may have lower demand for gasoline, leading to lower prices.

### Taking log for better fit
```{r}
model4<-lm(gasoline_avg~
             brand_cat+
             log(brand_in_sett+0.000001)+
             log(n_competitors_other_brand+0.0000001)+
             hhi_brand+
             log(pop_density), train_data)

vif(model4) #tolerable multicollinearity
bptest(model4) #the residuals are heteroskedastic
resettest(model4) #incorrectly specified
#anova(model3, model4) #anova logic breaks bc pop.density has lower sample size
```
Highway stations primarily serve transient drivers — travelers with limited choice of alternatives. They can’t easily shop around or detour into nearby towns for cheaper fuel.
By far the most economically significant effect

```{r}
stargazer::stargazer(model1, model2, model3, model4,
          se = list(
            sqrt(diag(vcovHC(model1, type = "HC1"))),
            sqrt(diag(vcovHC(model2, type = "HC1"))),
            sqrt(diag(vcovHC(model3, type = "HC1"))),
            sqrt(diag(vcovHC(model4, type = "HC1")))
          ),
          column.labels = c("M1", "M2", "M3", "M4"),
          type = "text",
          digits = 3,
          title = "Regression results with robust (HC1) standard errors")
```

## Continuing with Model  -now for location specific effects (did not run specifications after each model in this case, summary table includes them)

```{r}

model5<-lm(gasoline_avg~
             brand_cat+
             log(brand_in_sett+0.000001)+
             log(n_competitors_other_brand+0.0000001)+
             hhi_brand+
             log(pop_density)+
             on_highway, train_data)
waldtest(model4, model5)
```

```{r}
model6<-lm(gasoline_avg~
             brand_cat+
             log(brand_in_sett+0.000001)+
             log(n_competitors_other_brand+0.0000001)+
             hhi_brand+
             log(pop_density)+
             on_highway+
             dist_border_km, train_data)

waldtest(model5, model6) #will not include border distance in km
```

```{r}
model7<-lm(gasoline_avg~
             brand_cat+
             log(brand_in_sett+0.000001)+
             log(n_competitors_other_brand+0.0000001)+
             hhi_brand+
             log(pop_density)+
             on_highway+
             near_border_10km, train_data)

waldtest(model5, model7) #will not include 10km dummy
```

```{r}
model8<-lm(gasoline_avg~
             brand_cat+
             log(brand_in_sett+0.000001)+
             log(n_competitors_other_brand+0.0000001)+
             hhi_brand+
             log(pop_density)+
             on_highway+
             near_border_20km, train_data)

waldtest(model5, model8) #will not include 20km dummy
```

```{r}
stargazer::stargazer(model5, model6, model7, model8,
          se = list(
            sqrt(diag(vcovHC(model5, type = "HC1"))),
            sqrt(diag(vcovHC(model6, type = "HC1"))),
            sqrt(diag(vcovHC(model7, type = "HC1"))),
            sqrt(diag(vcovHC(model8, type = "HC1")))
          ),
          column.labels = c("M5", "M6", "M7", "M8"),
          type = "text",  
          digits = 3,
          title = "Regression results with robust (HC1) standard errors")
```

## Interaction terms

```{r}

## highway stations may be forced to reduce prices near border crossings as travelers have to option to refuel across the border instead

model9<-lm(gasoline_avg~
             brand_cat+
             log(brand_in_sett+0.000001)+
             log(n_competitors_other_brand+0.0000001)+
             hhi_brand+
             log(pop_density)+
             on_highway+
             near_border_10km*on_highway,
            train_data)

model10<-lm(gasoline_avg~
             brand_cat+
             log(brand_in_sett+0.000001)+
             log(n_competitors_other_brand+0.0000001)+
             hhi_brand+
             log(pop_density)+
             on_highway+
             near_border_20km*on_highway,
            train_data)

waldtest(model5, model9)
waldtest(model5, model10) #interaction term between 20km and highway dummy is worth including in the model

table(train_data$near_border_20km, train_data$on_highway) #there are only a limited amount of observations but 20km from the border and on a highway - footnote

#Interpetation
#Stations located on highways charge substantially more for gasoline, but this premium is significantly smaller if they are close to a border crossing. Border proximity reduces the monopoly power of highway stations, likely because consumers can refuel across the border or because competition near borders is more intense.

```
### Final model (M5)
```{r}
vif(model10) 

```
Tolerable multicollinearity

```{r}
bptest(model10) #heteroskedastic
library(sandwich)


stargazer::stargazer(model5, model5,
          se = list(NULL, sqrt(diag(vcovHC(model10, type = "HC1")))),
          column.labels = c("M10", "M10_robust"),
          type = "text",
          header = FALSE,
          digits = 3)
```
Heteroskedastic-robust standard errors 

Residual plot
```{r}

par(mfrow = c(1, 2))

plot(fitted(model1), resid(model1),
     main = "M1: Residuals vs Fitted",
     xlab = "Fitted Values",
     ylab = "Residuals",
     pch = 19, col = "gray40")
abline(h = 0, col = "red", lty = 2)

plot(fitted(model10), resid(model10),
     main = "M10: Residuals vs Fitted",
     xlab = "Fitted Values",
     ylab = "Residuals",
     pch = 19, col = "gray40")
abline(h = 0, col = "red", lty = 2)

par(mfrow = c(1, 1))

```
QQplots
```{r}
par(mfrow = c(1,2))
qqnorm(residuals(model1), main = "M1 Residuals")
qqline(residuals(model1), col = "red")
qqnorm(residuals(model10), main = "M10 Residuals (Final)")
qqline(residuals(model10), col = "red")
par(mfrow = c(1,1))
```


## Model comparison summary for gasoline
```{r}
library(lmtest)
library(tibble)
library(kableExtra)

model_comparison <- tibble(
  Model = paste0("M_gasoline", 1:10),
  AIC = c(
    AIC(model1), AIC(model2), AIC(model3), AIC(model4),
    AIC(model5), AIC(model6), AIC(model7), AIC(model8),
    AIC(model9), AIC(model10)
  ),
  BIC = c(
    BIC(model1), BIC(model2), BIC(model3), BIC(model4),
    BIC(model5), BIC(model6), BIC(model7), BIC(model8),
    BIC(model9), BIC(model10)
  ),
  Testing_RMSE = c(
    sqrt(mean((test_data$gasoline_avg - predict(model1, newdata = test_data))^2, na.rm = TRUE)),
    sqrt(mean((test_data$gasoline_avg - predict(model2, newdata = test_data))^2, na.rm = TRUE)),
    sqrt(mean((test_data$gasoline_avg - predict(model3, newdata = test_data))^2, na.rm = TRUE)),
    sqrt(mean((test_data$gasoline_avg - predict(model4, newdata = test_data))^2, na.rm = TRUE)),
    sqrt(mean((test_data$gasoline_avg - predict(model5, newdata = test_data))^2, na.rm = TRUE)),
    sqrt(mean((test_data$gasoline_avg - predict(model6, newdata = test_data))^2, na.rm = TRUE)),
    sqrt(mean((test_data$gasoline_avg - predict(model7, newdata = test_data))^2, na.rm = TRUE)),
    sqrt(mean((test_data$gasoline_avg - predict(model8, newdata = test_data))^2, na.rm = TRUE)),
    sqrt(mean((test_data$gasoline_avg - predict(model9, newdata = test_data))^2, na.rm = TRUE)),
    sqrt(mean((test_data$gasoline_avg - predict(model10, newdata = test_data))^2, na.rm = TRUE))
  ),
  BP_p = c(
    bptest(model1)$p.value,
    bptest(model2)$p.value,
    bptest(model3)$p.value,
    bptest(model4)$p.value,
    bptest(model5)$p.value,
    bptest(model6)$p.value,
    bptest(model7)$p.value,
    bptest(model8)$p.value,
    bptest(model9)$p.value,
    bptest(model10)$p.value
  ),
  RESET_p = c(
    resettest(model1, power = 2:3, type = "fitted")$p.value,
    resettest(model2, power = 2:3, type = "fitted")$p.value,
    resettest(model3, power = 2:3, type = "fitted")$p.value,
    resettest(model4, power = 2:3, type = "fitted")$p.value,
    resettest(model5, power = 2:3, type = "fitted")$p.value,
    resettest(model6, power = 2:3, type = "fitted")$p.value,
    resettest(model7, power = 2:3, type = "fitted")$p.value,
    resettest(model8, power = 2:3, type = "fitted")$p.value,
    resettest(model9, power = 2:3, type = "fitted")$p.value,
    resettest(model10, power = 2:3, type = "fitted")$p.value
  )
)


model_comparison %>%
  mutate(
    across(c(AIC, BIC, Testing_RMSE, BP_p, RESET_p), ~round(.x, 3))
  ) %>%
  kable(
    caption = "Model comparison (M1–M10) including AIC, BIC, out-of-sample RMSE, and diagnostic test results",
    digits = 3
  ) %>%
  kable_styling(full_width = FALSE)

```



# II. Diesel
```{r}
model_diesel1<-lm(diesel_avg~
             brand_cat, train_data)

bptest(model_diesel1) 
resettest(model_diesel1) #It’s testing something trivial: whether a polynomial transformation of a single variable adds explanatory power
```

### Controlled for by local market structure
```{r}
model_diesel2<-lm(diesel_avg~
             brand_cat+
             brand_in_sett+
             n_competitors_other_brand+
             hhi_brand, train_data)

vif(model_diesel2) #tolerable multicollinearity
bptest(model_diesel2) #the residuals are heteroskedastic
resettest(model_diesel2) #incorrectly specified
waldtest(model_diesel1, model_diesel2) #local market structure increases model_diesel fit signficantly

```
Smaller and discount brands both operate with lower prices on average
An increase of stations of one brand increases its local monopoly effect as well as their brand effect. Their dense local presence might signal reliability or service quality, allowing higher prices.
An increase of competitive stations causes an effect the other way around

### Controlled for by local market structure and population density
```{r}

model_diesel3<-lm(diesel_avg~
             brand_cat+
             brand_in_sett+
             n_competitors_other_brand+
             hhi_brand+
             pop_density, train_data)

vif(model_diesel3) #tolerable multicollinearity
bptest(model_diesel3) #the residuals are heteroskedastic
resettest(model_diesel3) #incorrectly specified
#waldtest(model_diesel2, model_diesel3) #anova logic breaks bc pop.density has lower sample size
```
Higher throughput (more customers per station) may allow operators to maintain margins with lower prices.
Higher density - cities, where public transport is more widely available - may have lower demand for diesel, leading to lower prices.

### Taking log for better fit
```{r}
model_diesel4<-lm(diesel_avg~
             brand_cat+
             log(brand_in_sett+0.000001)+
             log(n_competitors_other_brand+0.0000001)+
             hhi_brand+
             log(pop_density), train_data)

vif(model_diesel4) #tolerable multicollinearity
bptest(model_diesel4) #the residuals are heteroskedastic
resettest(model_diesel4) #incorrectly specified
#anova(model_diesel3, model_diesel4) #anova logic breaks 
```
Highway stations primarily serve transient drivers — travelers with limited choice of alternatives. They can’t easily shop around or detour into nearby towns for cheaper fuel.
By far the most economically significant effect

```{r}
stargazer::stargazer(model_diesel1, model_diesel2, model_diesel3, model_diesel4,
          se = list(
            sqrt(diag(vcovHC(model_diesel1, type = "HC1"))),
            sqrt(diag(vcovHC(model_diesel2, type = "HC1"))),
            sqrt(diag(vcovHC(model_diesel3, type = "HC1"))),
            sqrt(diag(vcovHC(model_diesel4, type = "HC1")))
          ),
          column.labels = c("M1", "M2", "M3", "M4"),
          type = "text",
          digits = 3,
          title = "Regression results with robust (HC1) standard errors")
```

## Continuing with model_diesel  -now for location specific effects (did not run specifications after each model_diesel in this case, summary table includes them)

```{r}

model_diesel5<-lm(diesel_avg~
             brand_cat+
             log(brand_in_sett+0.000001)+
             log(n_competitors_other_brand+0.0000001)+
             hhi_brand+
             log(pop_density)+
             on_highway, train_data)
waldtest(model_diesel4, model_diesel5) #highway worth including
```

```{r}
model_diesel6<-lm(diesel_avg~
             brand_cat+
             log(brand_in_sett+0.000001)+
             log(n_competitors_other_brand+0.0000001)+
             hhi_brand+
             log(pop_density)+
             on_highway+
             dist_border_km, train_data)

waldtest(model_diesel5, model_diesel6) #will not include border distance in km
```

```{r}
model_diesel7<-lm(diesel_avg~
             brand_cat+
             log(brand_in_sett+0.000001)+
             log(n_competitors_other_brand+0.0000001)+
             hhi_brand+
             log(pop_density)+
             on_highway+
             near_border_10km, train_data)

waldtest(model_diesel5, model_diesel7) #will not include 10km dummy
```

```{r}
model_diesel8<-lm(diesel_avg~
             brand_cat+
             log(brand_in_sett+0.000001)+
             log(n_competitors_other_brand+0.0000001)+
             hhi_brand+
             log(pop_density)+
             on_highway+
             near_border_20km, train_data)

waldtest(model_diesel5, model_diesel8) #will not include 20km dummy (on its own)
```

```{r}
stargazer::stargazer(model_diesel5, model_diesel6, model_diesel7, model_diesel8,
          se = list(
            sqrt(diag(vcovHC(model_diesel5, type = "HC1"))),
            sqrt(diag(vcovHC(model_diesel6, type = "HC1"))),
            sqrt(diag(vcovHC(model_diesel7, type = "HC1"))),
            sqrt(diag(vcovHC(model_diesel8, type = "HC1")))
          ),
          column.labels = c("M5", "M6", "M7", "M8"),
          type = "text",  
          digits = 3,
          title = "Regression results with robust (HC1) standard errors")
```

## Interaction terms

```{r}

## highway stations may be forced to reduce prices near border crossings as travelers have to option to refuel across the border instead

model_diesel9<-lm(diesel_avg~
             brand_cat+
             log(brand_in_sett+0.000001)+
             log(n_competitors_other_brand+0.0000001)+
             hhi_brand+
             log(pop_density)+
             on_highway+
             near_border_10km*on_highway,
            train_data)

model_diesel10<-lm(diesel_avg~
             brand_cat+
             log(brand_in_sett+0.000001)+
             log(n_competitors_other_brand+0.0000001)+
             hhi_brand+
             log(pop_density)+
             on_highway+
             near_border_20km*on_highway,
            train_data)

waldtest(model_diesel5, model_diesel9)
waldtest(model_diesel5, model_diesel10) #interaction term between 20km and highway dummy is worth including in the model_diesel

#there are only a limited amount of observations but 20km from the border and on a highway - footnote

#Interpetation
#Stations located on highways charge substantially more for diesel, but this premium is significantly smaller if they are close to a border crossing. Border proximity reduces the monopoly power of highway stations, likely because consumers can refuel across the border or because competition near borders is more intense.

#Positive competitor coefficient: competition is stronger where demand and purchasing power are higher.
```
### Final model (M10)
```{r}
vif(model_diesel10) 
```
Tolerable multicollinearity

```{r}
bptest(model_diesel10) #heteroskedastic
library(sandwich)


stargazer::stargazer(model_diesel10, model_diesel10,
          se = list(NULL, sqrt(diag(vcovHC(model_diesel10, type = "HC1")))),
          column.labels = c("OLS (regular SEs)", "OLS (robust SEs)"),
          type = "text",
          header = FALSE,
          digits = 3)
```
Heteroskedastic-robust standard errors 

Residual plot
```{r}

par(mfrow = c(1, 2))

plot(fitted(model_diesel1), resid(model_diesel1),
     main = "M1: Residuals vs Fitted",
     xlab = "Fitted Values",
     ylab = "Residuals",
     pch = 19, col = "gray40")
abline(h = 0, col = "red", lty = 2)

plot(fitted(model_diesel10), resid(model_diesel10),
     main = "M10_diesel: Residuals vs Fitted",
     xlab = "Fitted Values",
     ylab = "Residuals",
     pch = 19, col = "gray40")
abline(h = 0, col = "red", lty = 2)

par(mfrow = c(1, 1))

```

QQplots
```{r}
par(mfrow = c(1,2))
qqnorm(residuals(model_diesel1), main = "M1_dieseel Residuals")
qqline(residuals(model_diesel1), col = "red")
qqnorm(residuals(model_diesel10), main = "M10_diesel Residuals (Final)")
qqline(residuals(model_diesel10), col = "red")
par(mfrow = c(1,1))
```


## model_diesel comparison summary for
```{r}
library(lmtest)
library(tibble)
library(kableExtra)

model_diesel_comparison <- tibble(
  model_diesel = paste0("M_diesel", 1:10),
  AIC = c(
    AIC(model_diesel1), AIC(model_diesel2), AIC(model_diesel3), AIC(model_diesel4),
    AIC(model_diesel5), AIC(model_diesel6), AIC(model_diesel7), AIC(model_diesel8),
    AIC(model_diesel9), AIC(model_diesel10)
  ),
  BIC = c(
    BIC(model_diesel1), BIC(model_diesel2), BIC(model_diesel3), BIC(model_diesel4),
    BIC(model_diesel5), BIC(model_diesel6), BIC(model_diesel7), BIC(model_diesel8),
    BIC(model_diesel9), BIC(model_diesel10)
  ),
  Testing_RMSE = c(
    sqrt(mean((test_data$gasoline_avg - predict(model_diesel1, newdata = test_data))^2, na.rm = TRUE)),
    sqrt(mean((test_data$gasoline_avg - predict(model_diesel2, newdata = test_data))^2, na.rm = TRUE)),
    sqrt(mean((test_data$gasoline_avg - predict(model_diesel3, newdata = test_data))^2, na.rm = TRUE)),
    sqrt(mean((test_data$gasoline_avg - predict(model_diesel4, newdata = test_data))^2, na.rm = TRUE)),
    sqrt(mean((test_data$gasoline_avg - predict(model_diesel5, newdata = test_data))^2, na.rm = TRUE)),
    sqrt(mean((test_data$gasoline_avg - predict(model_diesel6, newdata = test_data))^2, na.rm = TRUE)),
    sqrt(mean((test_data$gasoline_avg - predict(model_diesel7, newdata = test_data))^2, na.rm = TRUE)),
    sqrt(mean((test_data$gasoline_avg - predict(model_diesel8, newdata = test_data))^2, na.rm = TRUE)),
    sqrt(mean((test_data$gasoline_avg - predict(model_diesel9, newdata = test_data))^2, na.rm = TRUE)),
    sqrt(mean((test_data$gasoline_avg - predict(model_diesel10, newdata = test_data))^2, na.rm = TRUE))
  ),
  BP_p = c(
    bptest(model_diesel1)$p.value,
    bptest(model_diesel2)$p.value,
    bptest(model_diesel3)$p.value,
    bptest(model_diesel4)$p.value,
    bptest(model_diesel5)$p.value,
    bptest(model_diesel6)$p.value,
    bptest(model_diesel7)$p.value,
    bptest(model_diesel8)$p.value,
    bptest(model_diesel9)$p.value,
    bptest(model_diesel10)$p.value
  ),
  RESET_p = c(
    resettest(model_diesel1, power = 2:3, type = "fitted")$p.value,
    resettest(model_diesel2, power = 2:3, type = "fitted")$p.value,
    resettest(model_diesel3, power = 2:3, type = "fitted")$p.value,
    resettest(model_diesel4, power = 2:3, type = "fitted")$p.value,
    resettest(model_diesel5, power = 2:3, type = "fitted")$p.value,
    resettest(model_diesel6, power = 2:3, type = "fitted")$p.value,
    resettest(model_diesel7, power = 2:3, type = "fitted")$p.value,
    resettest(model_diesel8, power = 2:3, type = "fitted")$p.value,
    resettest(model_diesel9, power = 2:3, type = "fitted")$p.value,
    resettest(model_diesel10, power = 2:3, type = "fitted")$p.value
  )
)


model_diesel_comparison %>%
  mutate(
    across(c(AIC, BIC, Testing_RMSE, BP_p, RESET_p), ~round(.x, 3))
  ) %>%
  kable(
    caption = "Model comparison for diesel (M1–M10) including AIC, BIC, out-of-sample RMSE, and diagnostic test results",
    digits = 3
  ) %>%
  kable_styling(full_width = FALSE)

```

Final models with robust standard errors
```{r}
stargazer::stargazer(model10, model_diesel10,
          se = list(
            sqrt(diag(vcovHC(model10, type = "HC1"))),
            sqrt(diag(vcovHC(model_diesel10, type = "HC1")))
          ),
          type = "text",  
          digits = 3,
          title = "Regression results with robust (HC1) standard errors")

stargazer::stargazer(model10, model_diesel10, type="text")
```
